---
title: Отчёт 6
---
:toc-title: Содержание
:toc:

= Контрольные вопросы

[text-right]
--
 Выполнил студент группы КЭ-413
 Ульданов Данил
--

:imagesdir: MySixtImg
:figure-caption: Рисунок
:table-caption: Таблица
:stem:



== 1. Что такое POD типы данных?
Простая структура данных (англ. plain old data, POD) — в современных языках программирования высокого уровня тип данных,
имеющий жёстко определённое расположение полей в памяти, не требующий ограничения доступа и автоматического управления.
Переменные такого типа можно копировать простыми процедурами копирования участков памяти наподобие memcpy.

== 2. Назовите все виды типов в языке С++
Для нашего микроконтроллера компилятор поддерживает следующие типы:
[#Типы данных в С++]
.Типы данных в С++
image::Figure3.png[800, 1280]

=== Встроенные типы
[#Встроенные типы С++]
.Встроенные типы С++
[options="header"]
[cols="2,1,7"]
|=====================
|Тип | Длина |Комментарий
|*bool*| 1| Представляет значения, которые могут быть или *true*, или *false*.
|*char*|1	| Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.
|*unsigned char*| 1 |	Аналог байта. В С++17 стандарте появился тип std::byte
|*int*|	4 |Целочисленное значение. Выбор по умолчанию для целых чисел
|*unsigned int*| 4| Беззнаковое целое число
|*float*| 4	|Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами
|*double*| 8	|Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой
|=====================

==== Размеры типов данных
Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров
типов существует правило:
[.source, cpp]
----
1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
std::uint32_t:: целое беззнаковое длиной 32 бита
std::int64_t::  целое знаковое длинной 64 бита
std::uint8_t:: целое знаковое длинной 8 бит

=== Пользовательские типы
Вы можете определить свой тип сами, либо сделать псевдоним типа. Любой класс или структура,
определенная вами, будет являться вашим типом. Например:
[.source, cpp]
----
template<typename T>
struct Complex
{
  Complex(T r, T im): real{r}, imaginary{im} {} ;
  operator T { return sqrt(real*real + imaginary* imaginary) ;}
  Complex operator +(Complex value)
  {
    return Complex(real+ value.real, imaginary + value.imaginary) ;
  }
  private:
  T real; //вещественная часть
  T imaginary //мнимая часть
} ;

int main()
{
  Complex<float> value1(3.0f, 4.0f) ;
  Complex<float> value1(1.0f, 2.0f) ;
  value1 += value2 ;
  return 0;
}
----

=== Адресные  типы
Каждой переменной содержащей данные соответствует некий адрес памяти.
К переменной можно обратиться непосредственно обращаясь к самой переменной,
либо можно обратиться косвенно, через указатель или ссылку.

Указатель это переменная, которая хранит адрес какой-то другой переменной:
[source, cpp]

----
int main() {
  int  c = 463 ;   # <1>
  int* ptr = &c ;  # <2>
  return 0;
}
----
[.notes]
--
<1> Объявляем переменную *c* типа *int*
<2> объявляем указатель *ptr* на переменную *c* типа *int*
--

[#Указатель]
.Указатель
image::Figure5.png[400, 400]
Помимо указателей к адресным типам данных относятся и ссылки.
Ссылка это псевдоним переменной, характеризующаяся следущими свойствами:

• У ссылки нельзя взять адрес. Если применить оператор взятия адреса к ней, то будет
выведен адрес переменной, на которую она ссылается
• Ссылка ведет себя почти также как константный указатель. Её нельзя изменять,
складывать, вычитать
• Ссылки нельзя сравнивать
• Ссылка не может быть не проинициализирована

== 3. Что такое пользовательский тип?
Пользовательские типы данных — это типы данных, которые могут быть созданы пользователем на основе того, что доступно в языке.

== 4. Назовите модификаторы типов
[#Встроенные типы С++ модификаторы]
.Встроенные типа С++ модификаторы
[options="header"]
[cols="2,1, 7"]
|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

== 5. Назовите правило установки размеров типов
Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров
типов существует правило:
[.source, cpp]
----
1             <= sizeof(char)     <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
std::uint32_t:: целое беззнаковое длиной 32 бита
std::int64_t::  целое знаковое длинной 64 бита
std::uint8_t:: целое знаковое длинной 8 бит

== 6. Что делает оператор sizeof()?
Sizeof - это унарный оператор в языках программирования C и C++.
Он генерирует размер хранилища выражения или типа данных, измеряемый в количестве единиц измерения размера символов.

== 7. Что характеризует тип std::size_t
Тип size_t беззнаковый, создан специально для хранения размера объектов любых типов и имеет достаточную для этого разрядность.
Разрядность зависит от платформы: на 32-битных платформах может составлять 32 бита, на 64-битных — 64 бита.

== 8. Назовите фиксированные типы целых в библиотеке std
.Типы целых в библиотеке std
[width="100%",options="header"]
|====================
|  Название| Тип  | Диапазон значений
| int8_t  | 1 байт signed |от -128 до 127
| uint8_t | 1 байт unsigned|от 0 до 255
| int16_t | 2 байта signed |от -32 768 до 32 767
| int16_t | 2 байта unsigned |от 0 до 65 535
| int32_t | 4 байта signed |от -2 147 483 648 до 2 147 483 647
| uint32_t| 4 байта unsigned|от 0 до 4 294 967 295
| int64_t | 8 байт signed| от -9 223 372 036 854 775 808 до
9 223 372 036 854 775 807
| uint64_t| 8 байт unsigned | от 0 до 18 446 744 073 709 551 615
|====================
Доступ к этим типам осуществляется через подключение заголовочного файла cstdint (находятся эти типы данных в пространстве имён std).

== 9. Что такое псевдоним типа?
Для того, чтобы было более понятнее работать с типом можно вводить их псевдонимы (alias).
С помощью ключевого слова *using*:
[source, cpp]

----
int main() {
  using tU32 = unsigned int ;  # <1>
  tU32 i = 10U ;               # <2>

}
----
[.notes]
--
<1> Объявляем псевдоним типа unsigned int
<2> Определяем переменную типа unsigned int
--

== 10. Что такое явное и неявное преобразование типа?
=== Неявное
Базовые/простые типы неявно можно привести друг к другу. Т.е
[.source, cpp]
----
int a = 0;    # <1>
char b = 512; # <2>
int c = 3.14; # <3>
bool d = -4;  # <4>
----
<1> Присваимаем знаковое целое(int) число переменной целого типа;
<2> Присваиваем знаковое целое(int) число переменной типа char. Результат в b 0 ;
<3> Присваиваем число с плавающей точкой(double) к переменной типа int. Результат в c 3;
<4> Присваиваем знаковое целое(int) к переменной типа bool. Результат в d true.

=== Явное
Так как компилятор может сделать что-то неожиданное,
то не нужно использовать неявное преобразование типа.
Вместо этого, лучше указать компилятору явное преобразование из одного типа в другой.
В этом случае, вы говорите компилятору, что я понимаю, что я делаю, это именно так и задумано

== 11. Какие явные преобразования типов вы знаете?
Для преобразований из одного типа в другой используют 4 варианта преобразования:

* static_cast - позволяет сделать приведение близких типов;
[source, cpp]

----
int a = static_cast<int>(0);// Явно говорим, что 0 должен восприниматься как тип (int)
----

* const_cast -
* reinterpret_cast - преобразует типы, несовместимыми друг с другом
[.source, cpp]
----
auto ptr = reinterpret_cast<volatile uint32_t *>(0x40010000) ; // Преобразует адрес 0x40010000 в указатель типа volatile uint32_t
auto value = *ptr ; // Записывает в переменную value (типа) значение лежащее по указателю ptr, указывающего на адрес
0x40010000
----

* dynamic_cast -

== 12. Что делает reinterpret_cast?
*reinterpret_cast* преобразует типы, несовместимыми друг с другом, и используется для:

* своего собственного типа данных
* указателя в интегральный тип
* интегрального типа в указатель
* указателя одного типа в указатель другого типа
* указателя на функцию одного типа в указатель на функцию другого типа

== 13. Чем static_cast отличается от reinterpret_cast?
[#Отличие static_cast от reinterpret_cast]
.Отличие static_cast от reinterpret_cast
[options="header"]
[cols="10,10"]
|=====================
|static_cast                        | reinterpret_cast
|Операция static_cast в языке C++ осуществляет явное допустимое приведение типа данных | В C++ существует оператор reinterpret_cast , смысл которого заключается в приведении между типами, несовместимыми друг с другом
|Операции проводятся между типами одной группы, например встроенными типами данных (int в char, float в int, char в bool и т.д.) | Операции проводятся между разными группами типов данных, например встроенными и адресными (указатель в int)
|=====================

== 14. Что такое ОЗУ и ПЗУ?
Обычно микроконтроллер имеет постоянную память, из которой можно
только читать (ПЗУ) и оперативную память, из которой можно читать
и в которую можно писать (ОЗУ).

== 15. Каков размер памяти ARM Cortex микроконтроллеров.
• 512 кБайт памяти программ • 128 кБайт ОЗУ

== 16. По какой архитектуре разработан ARM Cortex микроконтроллер?
ARM является модифицированной гарвардской архитектурой.
Доступ к памяти осуществляется по одной шине, а уже устройство управления памятью
обеспечивает разделение шин при помощи управляющих сигналов: чтения, записи или
выбора области памяти.
Данные и код могут находится в одной и той же области памяти. В этом едином адресном
пространстве может находится и ПЗУ и ОЗУ и периферия. А это означает, что собственно и
код и данные могут попасть хоть куда(в ОЗУ или в ПЗУ) и это зависит только от
компилятора и линкера.

== 17. В чем отличие Гарвардской архитектуры от Архитектура ФонНеймана?
Принстонская архитектура,
которая часто называется архитектурой фон Неймана,
характеризуется использованием общей оперативной памяти
для хранения программ, данных, а также для организации стека.
Для обращения к этой памяти используется общая системная шина,
по которой в процессор поступают и команды, и данные.

Гарвардская архитектура характеризуется физическим разделением памяти команд (программ) и памяти данных.
Каждая память соединяется с процессором отдельной шиной, что позволяет одновременно с чтением-записью данных при выполнении текущей команды производить выборку и декодирование следующей команды.
Благодаря такому разделению потоков команд и данных и совмещению операций их выборки реализуется более высокая производительность, чем при использовании Принстонской архитектуры.

== 18. Где располагаются локальные переменные?
Переменные, которые являются локальными в функции располагаются в регистрах или в стеке.

== 19. Где располагаются статические переменные?
Статические переменные.
Такие переменные инициализируются единожды в памяти процессора.
Static означает, что та память, которая была выделена под эту
переменную не будет изменяться и закрепляется за этой переменной до конца работы приложения.


== 20. Где располагаются глобальные переменные?
Глобальные переменные так же как и статические располагаются в пямяти процессора.

== 21. Что такое стек?
В микроконтроллере стек - это непрерывная область памяти,
адресуемая специальными регистрами SP (указатель стека).

== 22. Что такое указатель?
Т.к. данные могут находится в ОЗУ или ПЗУ. Каждой переменной содержащей данные соответствует
некий адрес памяти. К переменной можно обратиться непосредственно обращаясь к самой переменной, тогда мы
можем напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель
или ссылку.
Указатель это переменная, которая хранит адрес какой-то другой переменной:
[source, cpp]

----
int main() {
  int  c = 463 ;   # <1>
  int* ptr = &c ;  # <2>
  return 0;
}
----
[.notes]
--
<1> Объявляем переменную *c* типа *int*
<2> объявляем указатель *ptr* на переменную *c* типа *int*
--

[#Указатель]
.Указатель
image::Figure5.png[400, 400]

== 23. Что такое разыменовывание указателя?
Операция разыменования указателя представляет выражение в виде *имя_указателя.
Эта операция позволяет получить объект по адресу, который хранится в указателе.

== 24. Что означает взятие адреса?
Адрес переменной можно получить, поставив перед именем переменной знак амперсанда (&), известный как оператор взятия адреса. Например:
[source, cpp]
----
foo = &myvar;
----
Это присвоит адрес переменной myvar переменной foo; ставя оператор взятия адреса (&) перед именем переменной myvar,
мы присваиваем переменной foo не содержимое переменной myvar, а её адрес.





== 25. Какие операции можно выполнять над указателями?
[.notes]
--
Указатели можно складывать, вычитать, сравнивать.
Но указатели должны быть одного типа.
Т.е. не нужно складывать укатели типа *char* * и *int**
--
[source, cpp]

----
int main() {
  int  arr[] = {1,2,3,4,5} ;    # <1>
  int* ptr = arr ;              # <2>

  ptr ++ ;                      # <3>
  int a = *(ptr + 4) ;          # <4>
  if(ptr != nullptr)            # <5>
    cout << a << ": " << *ptr;  # <6>
}
----
<1> Объявление массива *arr* из 5 элементов. В целом можно считать, что массив *arr* это указатель на первый элемент массива.
<2> Обявления указателя на массив типа *int* ;
<3> Увеличиваем указатель на 1. На самом деле мы смещаемся по адресам на размер равный *size_of(int)*, т.е. на 4 байта. Т.е
в данном случае указатель *ptr* стал указывать на элемент массива *arr[1]*.
<4> Объявляем переменную *а* типа *int* и присваиваем ей значение *аrr[4]*.
<5> Сравнение указателя с nullptr указателем.
<6> Вывод значения *а* и значения по адресу в указателе *ptr*. Вывод (5: 2)

== 26. Что такое константный указатель?
Значение указателя (т.е. его адрес) нельзя изменить.

== 27. Что такое указатель на константу?
Адрес указывающий местоположение константы.

== 28. Что такое ссылка? В чем её отличие от указателя?
[source, cpp]
----
int main(){
  int a = 0;
  int &ref = a ;                # <1>
  ref = 10;                     # <2>
  cout << &ref << ": " << ref ; # <3>
  return 0 ;
}
----
<1> Объявляем ссылку на переменную *а*
<2> Записываем в переменную *а* число 10
<3> Выводим адрес перменной *а* и значение переменной *a*
[.notes]
--
Если указатель хранит адрес переменной, то ссылка псевдоним имя переменной, который ссылается на эту переменную. .
--
* У ссылки по сравненю с указателем нельзя взять адрес. Если применить оператор взятия адреса к ней, то будет выведен адрес
переменной, на которую она ссылается
* Ссылка ведет себя почти также как константный указатель.
* Ссылку нельзя изменять, складывать, вычитать
* Ссылки нельзя сравнивать
* Ссылка не может быть не проинициализирована.

== 29. Что такое регистр?
Сверхбыстрая память внутри процессора, предназначенная для хранения адресов и
промежуточных результатов вычислений (регистр общего назначения/регистр данных) или
данных, необходимых для работы самого процессора.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый
бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным
параметром микроконтроллера.

== 30. Что такое регистры общего назначения?
Регистры общего назначения расположены внутри ядра микроконтроллера(сверхбыстрая память).
Регистры общего назначения - это сверхбыстрая память внутри процессора,
предназначенная для хранения адресов и промежуточных результатов вычислений
(регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

== 31. Что такое регистры специального назначения?
Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления
процессором и периферийными устройствами.

[#Register]
.Схематичное изображение регистра
image::Figure1.png[800, 800]
[.notes]
--
* Название регистра
--
* Адрес регистра обозначается 32-битным шестнадцатеричным числом.
* Тип доступа к ячейкам регистра.
* Длина - количество ячеек в одном регистре. Мы будем работать с 32-битными регистрами.
* Поле - набор ячеек регистра, отвечающих за работу одной из функции микроконтроллера
* Значение поля - есть пространство всех возможных величин, которые может принимать поле

[.notes]
--
Значение поля зависит от длины поля. Т.е. если поле имеет длину 2, то существует 4 возможные
значения поля (0,1,2,3). Так же как у регистра, у полей и значений полей есть режим доступа (чтение,
записать, чтение и запись)
--

== 32. Как можно установить бит в регистре специального назначения?
[.notes]
--
Например, чтобы запустить таймер 1 на счет, необходимо в Таймере1, в регистре *CR1(Control Register1)*
в поле *CEN(Counter Enable)* установить значение 1 (Enable).
--
[#RegisterCR1]
.Регистр CR1 Таймера 1
image::Figure2.png[800, 800]

  Бит 0 CEN: Включить счетчик
      0: Счетчик включен: Disable
      1: Счетчик выключен: Enable

Здесь, CEN — это поле размером 1 бит имеющее смещение 0 относительно начала регистра.
А Enable(1) и Disable(0) это его возможные значения.
[source, cpp]
----
int main()
{
  *reinterpret_cast<uint32_t *>(0x40010000) |= 1 << 0 ; # <1>
  TIM1::CR1::CEN::Enable::Set() ;                       # <2>
}
----
<1> Записываем 1 в нулевой бит ячейки памяти (регистра) по адресу 0x40010000
<2> Тоже самое, но с использованием специального класса на С++

== 33. Объясните как вызывается функция
Вызов функции имеет вид имени функции с последующими круглыми скобками. Эти скобки могут быть пустыми, если функция не имеет аргументов. Если же аргументы в самой функции есть, их необходимо указать в круглых скобках.

Также существует такое понятие, как параметры функции по умолчанию. Такие параметры можно не указывать при вызове функции, т.к. они примут значение по умолчанию, указанно после знака присваивания после данного параметра и списке всех параметров функции.
[source,]
----
#include <iostream>
using namespace std;

void function_name ()
{
    cout << "Hello, world" << endl;
}
int main()
{
    function_name(); // Вызов функции
    return 0;
}
----

Если мы хотим вывести «Hello, world» где-то еще, нам просто нужно вызвать соответствующую функцию. В данном случае это делается так: function_name();


== 34. Что такое трансляция?
Трансляция - перевод с языка программирования на язык машинных команд (язык процессора)
Трансляция осуществляется с помощью специальных программ, называемых трансляторами.

== 35. Что такое компоновка?
В C+ +, функция может компоноваться либо как С+ +, либо как С функция. Пример объявления функции
с Си компоновкой:
[source, c]

----
extern "C" {
  int F(int);
}
----

Если вы хотите вызвать функции ассемблера из С++, то лучше объявить эту функцию, как имеющую тип
компоновки Си

== 36. Как лучше организовывать структуру проекта и почему?


== 37. Что такое операторы?
Операторы-наименьшая автономная часть языка программирования; команда или набор команд.
Программа обычно представляет собой последовательность инструкций.

== 38. Какие арифметические операторы вы знаете?
[#Арифметические операторы]
.Арифметические операторы
[options="header"]
[cols="4,2,4,8"]
|=====================
|Операция | Оператор | Пример | Описание
|Присваивание       | =     | a = b | Присваивает переменной значение
|Сложение           | +     | a + b | Суммирует два числа
|Вычитание          | -     | a - b | возвращает разность двух чисел, если они числовые
|Унарный плюс       | +     | +a | Унарный оператор + возвращает значение полученного операнда
|Унарный минус      | -     | -a | Унарный оператор - изменяет знак операнда на противоположный
|Умножение          | *     | a * b | Оператор умножения * вычисляет произведение операндов
|Деление            | /     | a / b | Оператор деления / делит левый операнд на правый
|Остаток от деления | %     | a % b | Оператор остатка % вычисляет остаток от деления левого операнда на правый
|Инкремет  (пост и предфиксный)| ++      | &#43;&#43;a  и  a&#43;&#43;  | Увеличивает переменную на единицу
|Декремент (пост и предфиксный)| - -     | --a и a--  | Уменьшает переменную на единицу
|=====================

== 39. Какие логические операторы вы знаете?
[#Логические операторы]
.Логические операторы
[options="header"]
[cols="4,2,2,8"]
|=====================
|Операция | Оператор | Пример | Описание
|Логическое отрицание, НЕ   | !     | !a    | Выполняет логическое отрицание операнда, возвращая true, если операнд имеет значение false, и false, если операнд имеет значение true.
|Логическое умножение, И    | &&    | a && b| Оператор & вычисляет логическое И для всех своих операндов. Результат операции x & y принимает значение true, если оба оператора x и y имеют значение true. В противном случае результат будет false.
|Логическое сложение, ИЛИ   | &#124;&#124;  |   a &#124; &#124;  b  | Оператор ^ вычисляет логическое исключение ИЛИ для всех своих операндов, возвращая true для x ^ y, если x имеет значение true и y имеет значение false или x имеет значение false и y имеет значение true.
|=====================

== 40. Какие побитовые операторы вы знаете?
[#Побитовые операторы]
.Побитовые операторы
[options="header"]
[cols="4,4,4, 8"]
|=====================
|Операция | Оператор  | Пример    | Описание
|Побитовая инверсия   | ~     | ~a    | Инвертирует биты (т.е. заменяет нули на единицы и наоборот)
|Побитовое И          | &     | a & b   | Позволяет сбрасывать биты в 0
|Побитовое ИЛИ        | &#124;   | a &#124; b | Устанавливае 1 в заданные биты
|Побитовое исключающее ИЛИ  | ^   | a ^ b | Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.  Исключающее ИЛИ b равно 1, если только a=1 или только b=1, но не оба одновременно a=b=1.
|Побитовый сдвиг влево  | <<   | a << b | Умножение числа на 2 ^ b
|Побитовый сдвиг вправо | >>   | a >> b | Деление числа на 2 ^ b
|=====================

== 41. Приведите пример переопределения оператора
Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>). Рассмотрим  пример:
[source,cpp]

----
class Integer
{
private:
    int value;
public:
    Integer(int i): value(i)
    {}
    const Integer operator+(const Integer& rv) const {
return (value + rv.value);
}
};
----


== 42. Какие еще операторы вы знаете?


== 43. Как сбросить бит с помощью битовых операторов?
[source,cpp]
----
BIT&=~(1<<0); //CБРОС БИТА С ПОМОЩЬЮ БИТОВЫХ ОПЕРАТОРОВ
----

== 44. Как установить бит с помощью битовых операторов?
Чтобы записать единицу в бит n:
[source,cpp]
----
x |= (1 << n);
----


Чтобы записать ноль в бит n:
[source,cpp]
----
x &= ~(1 << n);
----


== 45. Как поменять значение бита с помощью битовых операторов?
Если нужно инвертировать состояние бита:
[source,cpp]
----
x ^= (1 << n);
----


== 46. Какой микроконтроллер на отладочной плате XNUCLE ST32F411?
XNUCLEO-F411RE – это отладочная плата от компании Waveshare с поддержкой Arduino,
которая позволит изучить возможности микроконтроллера STM32F411RET6 на базе ядра Cortex-M3.

== 47. Какие блоки входят в состав микроконтроллера STM32F411?

image::Figure7.png[]

== 48. В чем отличие ядра CortexM4 от CortexM3?
[cols="4,4,4,4"]
|===
| Параметр​ | ARM7TDMI​ | ARM Cortex-M3​| ARM Cortex-M4​
| Архитектура​ | ARMv4T (Фон Неймана)​ | ARMv7 (Гарвардская)​ | ARMv7 (Гарвардская)​
| Набор инструкций​ | Thumb/ARM​ | Thumb/Thumb-2​ | Thumb/Thumb-2, DSP, SIMD, FP​
| Конвейер​ |  3 уровня​ | 3 уровня + предсказание ветвлений​ | 3 уровня + предсказание ветвлений​
| Прерывания​ | FIQ/IRQ​ | NMI (немаскируемые) + от 1 до 240 физических источников прерываний​ | NMI (немаскируемые) + от 1 до 240 физических источников прерываний​
| Длительность входа в обработчик прерывания​ |  24-42 цикла​ | 12 циклов​ | 12 циклов​
| Длительность переключения между обработчиками прерываний​ | 24 цикла​ | 6 циклов​ | 6 циклов​
| Режимы пониженного энергопотребления​ | Нет​ | Встроены​ | Встроены​
| Защита памяти​ | Нет​ | Блок защиты памяти с 8 областями​ | Блок защиты памяти с 8 областями​
| Производительность по тесту Dhrystone​ | 0,95 DMIPS/МГц |  1,25 DMIPS/МГц​ | 1,25 DMIPS/МГц​
| Энергопотребление ядра​ | 0,28 мВт/МГц​ | 0,19 мВт/МГц​ | 0,19 мВт/МГц​
| Аппаратный модуль работы с плавающей точкой ​| нет​ | нет​ | есть​
|===

== 49. Назовите основные характеристики микроконтроллера STM32F411.
Микроконтроллер имеет следующие характеристики:
[cols="a, a"]
|===
| *	32 разрядное ядро ARM Cortex-M4 | *	Блок работы с числами с плавающей точкой FPU
| *	512 кБайт памяти программ | *	128 кБайт ОЗУ
| * Встроенный 12 битный 16 канальный АЦП | *	DMA контроллер на 16 каналов
| *	USB 2.0 | *	3x USART
| * 5 x SPI/I2S | * 3x I2C
| * SDIO интерфейс для карт SD/MMC/eMMC | * Аппаратный подсчет контрольной суммы памяти программ CRC
| *	6 - 16 разрядных и 2 - 32 разрядных Таймера | *	1 - 16 битный для управления двигателями
| *	2  сторожевых таймера | *	1 системный таймер
| *	Работа на частотах до 100Мгц |* 81 портов ввода вывода
| *	Питание от 1.7 до 3.6 Вольт | * Потребление 100 мкА/Мгц
|===

== 50. Назовите дополнительные характеристики микроконтроллера STM32F411
[.notes]
--
Из дополнительных особенностей, которые понадобятся для лабораторных работ следует выделить:
--

*	Настраиваемые источники тактовой частоты
*	Настраиваемые на различные функции порты
*	Внутренний температурный сенсор
*	Таймеры с настраиваемым модулем ШИМ
*	DMA для работы с модулями (SPI, UART, ADC… )
*	12 разрядный ADC последовательного приближения
*	Часы реального времени
*	Системный таймер и спец. прерывания для облегчения и ускорения  работы ОСРВ

== 51. Какие источники тактирования есть у микроконтроллера STM32F411
* Для формирования системной тактовой частоты SYSCLK могут использоваться 4 основных источника:​
** HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​
** HSE (high-speed external) — внешний высокочастотный генератор.​
** PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей,
исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.
* Также имеются 2 вторичных источника тактового сигнала:​
** LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​
** LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц​

== 52. Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411
* Определить какие источники частоты нужны​
** Например, PLL нужен для USB​

* Включить нужный источник​
** Используя Clock Control register (RCC::CR)​

* Дождаться стабилизации источника ​
** Используя соответствующие биты (..RDY) Clock Control register ​(RCC::CR)

* Назначить нужный источник на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

* Дождаться пока источник не переключиться на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

== 53. Что такое ФАПЧ?
ФАПЧ (Фа́зовая автоподстроойка частоты) — система автоматического регулирования, подстраивающая фазу управляемого генератора так, чтобы она была равна фазе опорного сигнала, либо отличалась на известную функцию от времени.

== 54. Что делает следующий код?
[source, cpp]
--
int main()
{
    int StudentUdacha = 10; #<1>
    int PrepodUdachca = 0 ; #<1>
    StudentUdacha = StudentUdacha ^ PrepodUdachca ;
    PrepodUdachca = StudentUdacha ^ PrepodUdachca ;
    StudentUdacha ^= PrepodUdachca ;
}
--
[.notes]
--

<1> Присваивает значение 10 переменной типа int. Размерность переменной при этом определяется архитектурой микроконтроллера и в нашем случае составляет 4 байта







== Вывод
Я ответил на 54 вопроса и расширил сови знания о програмировании, если я что то забуду то всегда смогу посмотретьв этой файлик ;)




