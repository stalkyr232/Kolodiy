= Отчёт 2
:reproducible:

:description: MyNewProject
:keywords: AsciiDoc
:imagesdir: MyNewProjectImg
:figure-caption: Рисунок
:table-caption: Таблица

[.notes]
== Моя первая программа с нуля
Для создания проекта в программном обеспечении (ПО) IAR, нажмём Project->Create New Project:

.Создание нового проекта
image::CreateNewProject.png[]
Создадим пустой проект.

--
Таким образом появился новый пустой проект.
Любая программа начинается с функции main() - точки входа, следовательно,
напишем её в новосозданную программу.
--
Для того чтобы можно было загружать код в плату необходимо настроить проект 
под наш микроконтроллер. Для этого нажмём правой кнопкой мыши по проекту и 
выберем Options->General Options->Target.
Выберем "Device" ST STM32F411RC. 
На вкладке Debugger выберем Driver "ST-LINK". И на вкладке ST-LINK выберем "SWD".

image::STM32F411RC.png[]
image::ST_LINK.png[]
image::SWD.png[]
--
Затем настроим рабочую область, чтобы была возможность писать комментарии на
русском языке. Для этого нажимаем правой кнопкой мыши по рабочему полю и выбираем Character Encoding->More->Russian:

.Подключение русского языка для комментариев
image::RussianLangyage.png[]
--

=== Мигание светодиодом
Для мигания светодиодами понадобятся порты С.5,С.8,С.9.
Дадим тактирование на порт С. Для этого подключим библиотеку "rccregisters.hpp".
Вообще, компилятор знает где находятся стандартные библиотеки, но вот к созданным библиотекам необходимо прописывать путь.
Для того чтобы компилятор мог найти данный файл необходимо прописать пути к нему.
Для этого нажимаем правой клавишей мыши (ПКМ) по проекту и выбираем Options->C/C++Compiler->Preprocessor:

image::FilePath.png[]

Чтобы подключить к тактированию порт С, пропишем в коде:
--
[source, c++]
RCC::AHB1ENR::GPIOCEN::Enable::Set();
--
Далее подключим регистры порта С. Для этого добавим библиотеку "gpiocregisters.hpp".
--
Переведём порты С.5, С.8 и С.9 на выход, следующими строчками:
[source, c++]
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
--
Далее напишем код, который зажигает и тушит светодиод:
[source, c++]
uint8_t i = 0;
while(true)
{
    i++;
    if (i%2==0)
    {
        GPIOC::ODR::ODR8::High::Set(); // загорается светодиод
    }
    else
    {
        GPIOC::ODR::ODR8::Low::Set();  // светодиод тухнет
    }
}

Но, т.к. данный светодиод загорается и мгновенно тухнет, затем мгновенно загорается и
снова мгновенно тухнет, необходимо установить задержку, для этого пропишем следующую
функцию:
[source, c++]
void Delay(int zaderjka)
{
  for (int i=0; i<zaderjka;++i)
  {
    //Тут что-то написано
    volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
  }
}

В итоге получился вот такой код:
[source, c++]
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
//Функция задержки
void Delay(int zaderjka)
{
    for (int i=0; i<zaderjka;++i)
    {
        volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
    }
}
//Главная функция
int main()
{
    //Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порты c.5 c.8 c.9 перевести в режим вывода  
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    // Зажечь светодиод на порте С.8
    uint8_t i = 0;
    while(true) // Цикл для бесконечного моргания светодиодом
    {
        i++;
        Delay(1000000); // вызов функции задержки
        if (i%2==0) // условие на загорание/тушение светодиода
        {
            GPIOC::ODR::ODR8::High::Set(); // загорается светодиод
        }
        else
        {
            GPIOC::ODR::ODR8::Low::Set();  // светодиод тухнет
        }
    }
}



--
Добавим в программу порт С.9:
[source, c++]
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
//Функция задержки
void Delay(int zaderjka)
{
    for (int i=0; i<zaderjka;++i)
    {
        volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
    }
}
//Главная функция
int main()
{
    //Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порт в режим вывода перевести c.7 c.8 c.9
    GPIOC::MODER::MODER7::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    // Зажечь светодиод на порте С.8
    uint8_t i = 0;
    while(true) // Цикл для бесконечного моргания светодиодом
    {
        i++;
        Delay(1000000); // вызов функции задержки
        if (i%2==0) // условие на загорание/тушение светодиода
        {
            GPIOC::ODR::ODR8::High::Set(); // загорается светодиод
            GPIOC::ODR::ODR9::Low::Set();  // светодиод тухнет
        }
        else
        {
            GPIOC::ODR::ODR8::Low::Set();  // светодиод тухнет
            GPIOC::ODR::ODR9::High::Set(); // загорается светодиод
        }
    }
}
--



=== Оптимизация в IAR
Чтобы зайти в настройки оптимизации необходимо ПКМ щёлкнуть по проекту и выбрать
Options->C/C++Compiler->Optimizations. Здесь можно выбрать уровень оптимизации:

.Настройки оптимизации в IAR
image::Optimization.png[]

Уровень оптимизации отвечает за то, какой код компилятор может оптимизировать, т.е.
пустой код он просто не будет выполнять.
В коде выше в функции Delay(int zaderjka) имеется пустой код, который по сути ничего не делает:
[source, c++]
volatile int j = i;

volatile - ключевое слово языков C/C++, которое информирует компилятор о том,
что значение переменной может меняться из вне (не зависимо от работы программы),
например значение входного регистра порта может поменяться, если нажать на
кнопку, поэтому регистры являются volatile переменной и компилятор не будет
оптимизировать эту переменную.
--
Если закомментировать строчку "volatile int j = i;" и поставить уровень оптимизации "High",
то оба светодиода одновременно будут гореть:

image::Volatile.png[]

Если же раскомментировать строчку "volatile int j = i;", то светодиоды будут моргать снова
попеременно
--

=== Домашнее задание - "Ёлочка"
Так как светодиод с.7 на моей плате не работает, то был взят светодиод С.5 и под него написан следующий код:
[source, c++]
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
//Функция задержки
void Delay(int zaderjka)
{
  for (int i=0; i<zaderjka;++i)
  {
    //Тут что-то написано
    volatile int j = i; // без оптимизации, выполняет код просто так как он есть, для того чтобы работала задержка
    // если включить оптимизацию на полную и закоментить volatile, то светодиоды все горят
    // с раскоментированным volatile задержка выполняется
  }
}
//Главная функция
int main()
{
    //Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порт в режим вывода перевести c.5 c.8 c.9
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    // Зажечь светодиоды
    uint8_t i = 0; // переменная для зажигания и тушения светодиодов
    while(true)// цикл для бесконечного моргания светодиодом
    {
        i++;
        if (i%2==0)  // Условие на загорание/тушение светодиода
        {
            GPIOC::ODR::ODR5::High::Set(); // загорается светодиод
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR8::High::Set(); // загорается светодиод
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR9::High::Set();  // светодиод тухнет
            Delay(2000000);  // Вызов функции задержки
        }
        else
        {
            GPIOC::ODR::ODR7::Low::Set();  // светодиод тухнет
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR8::Low::Set();  // светодиод тухнет
            Delay(2000000);  // Вызов функции задержки
            GPIOC::ODR::ODR9::Low::Set();  // светодиод тухнет
            Delay(2000000);  // Вызов функции задержки
        }
    }
}

video::ChristmasTree.mp4[]

=== Выводы

Я научился создавать проект с нуля для STM32 без Cube MX,подключать библиотеки к проекту, подключать тактирование на порты,
узнал про volatile, изучил функционал программы IAR, написал программу для мигания светодиодами но не понял почему програматор не работает с USB хаба :( .

