---
title: Отчёт по таймерам
---

:reproducible:

:description: Progect ONE
:keywords: AsciiDoc


:toc-title: Содержание
:toc:

[text-right]
--
 Выполнил студент группы КЭ-413
 Ульаднов Данил
--
[.notes]
Таймером называется средство микропроцессора, служащее для измерения времени и реализации задержек. Основой таймера служит суммирующий счетчик, который считает количество импульсов генератора тактовой частоты.


== Системный таймер
Системный таймер имеет 3 регистра:

1. Регистр с которым сравнивается, до которого считать должен таймер (VAL).
2. Регистр куда помещается значение до которого таймер должен считать (LOAD).
3. Регистр управления таймером (CTRL).

Опишем алгоритм подключения и настройки системного таймера

1. Записать в регистре LOAD значение задержки, предварительно его рассчитав.
2. Записать в текущее значение счетчика в регистр VAL - "0", для сброса счётчика.
3. Подключить системный таймер к частоте процессора в регистре CTRL ().
4. Включить системный таймер в регистре CTRL.
5. Дождаться готовности флага COUNTFLAG в регистре CTRL.

По заданному алгоритму подключим таймер к проекту "Гирлянда".
Подключим библиотеку в файл *main.cpp* для работы с регистрами таймера.
Сюда же добавим константы, чтобы была возможность в функцию Delay()
передать значение задержки в миллисекундах.


.Файл main.cpp
[source, c++]
-------
#include "stkregisters.hpp" // Описание регистров системного таймера
constexpr std::uint32_t SystemClock = 8'000'000U; // тактирование внутреннего генератора, 1 такт = 8 000 000 Гц
constexpr std::uint32_t OneMillisecondRation = 1000U; // коэффициент деления
-------



Осуществим задержку через таймер. Следуя алгоритму,
сперва запишем в регистр LOAD значение до которого таймер будет считать.
Для этого рассчитаем требуемое значение задержки в переменной *delayCounts*.
Далее настроим таймер, сбросим его и запишем в *LOAD* рассчитанное значение.
Далее включаем таймер и он начинает считать до заданного значения (заданное количество миллисекунд),
после того как таймер досчитает, программа выйдет из цикла и таймер обнулится.

.Функция задержки - Delay()
[source, c++]
-------
// -------------------------Функция задержки-----------------------------------
void Delay(std::uint32_t milliseconds) // milliseconds - передаём требуемое количество миллисекунд для задержки
{
  const std::uint32_t delayCounts = milliseconds * SystemClock / OneMillisecondRation - 1U; // Расчёт значения таймера

//--------------Настройка таймера---
  STK::VAL::Write(0U);            // Сброс счётчика в "0"
  STK::LOAD::Write(delayCounts); // STK - модуль таймера, LOAD - регистр, в который записываем (Write(значение до которого считает счётчик))
//---------------------------------

  STK::CTRL::ENABLE::Enable::Set(); // Включение таймера
  while(!STK::CTRL::COUNTFLAG::Overflow::IsSet())
  {
     // Дожидаемся, пока в таймере установится флажок (COUNTFLAG::Overflow - счётчик достиг нуля), что он досчитатл до конца
  }
  STK::CTRL::ENABLE::Disable::Set(); // Выключение таймера
}
//------------------------------------------------------------------------------
-------

Т.е. в функцию Delay() приходит значение задержки в миллисекундах,
затем оно пересчитывается в переменной *delayCounts* и, полученное значение записывается в регистр *LOAD*.
Теперь задержка осуществляется ровно по времени.

== Домашнее задание таймер TIM5

Данный таймер не встроен в ядро микроконтролера а являеться дополнительной периферией от производителя.
Данный таймер- 32 битный.
Данный таймер, наравне с таймером TIM2 используется для:

* Переполнения - собитие по переполнению значения таймера.
* Захват сигнала (защёлка), т.е защёлкивает значение изменения значения (например на порте изменилась 1 на 0), записывая значение таймера, когда произошло это изменение.
* Сравнение, используется для задания периода.
* Событие-триггер, по истечению определённого значения таймера, запускается другая перифрия (АЦП, ШИМ).

Опишем алгоритм подключения и настройки таймера TIM5 для реализации задержки

1. Подать тактирование на модуль таймера через *RCC::APB1ENR*.
2. Установить делитель частоты для таймера в регистре *PSС*.
3. Установить источник генерации прерываний по событию переполнение с помощью бита *URS* в регистре *CR1*.
4. Установить значение до которого счетчик будет считать в регистре перезагрузке *ARR*.
5. Скинуть флаг генерации прерывания *UIF* по событию в регистре *SR*.
6. Установить начальное значение счетчика в "0" в регистре *CNT*.
7. Запустить счетчик с помощью бита *EN* в регистре *CR1*.
8. Проверять пока не будет установлен флаг генерации прерывания по событию *UIF* в регистре *SR*.
9. Как только флаг установлен остановить счетчик, сбросить бит *СEN* в регистре *CR1*, Сбросить флаг генерации прерывания *UIF* по событию в регистре *SR*.

По заданию требуется в функции Delay() заменить системный таймер на таймер TIM5.
Т.к. таймер не является частью ядра, то его необходимо подключать к тактовой шине.

.Задержка по таймеру TIM5
[source, c++]
-------
#include "tim5registers.hpp"  // Подключение таймера ТIM5

// -------------------------Функция задержки-----------------------------------
void Delay(std::uint32_t milliseconds)
{
  //--------------Настройка таймера
  TIM5::CNT::Write(0U);            // Сброс счётчика в "0"
  TIM5::ARR::Write(milliseconds);  // число до которого считает таймер
  //------------------------------

  TIM5::CR1::CEN::Enable::Set();     // Включение таймера
  while(!TIM5::SR::UIF::InterruptPending::IsSet())
  {
     // Для TIM5: Дожидаемся, пока в таймере установится флажок ( InterruptPending - счётчик достиг максимального значения)
  }
  TIM5::SR::UIF::NoInterruptPending::Set();
  TIM5::CNT::Write(0U);
  TIM5::CR1::CEN::Disable::Set(); // Выключение таймера
}
//------------------------------------------------------------------------------

int main()
{
  RCC::APB1ENR::TIM5EN::Enable::Set();             // подали тактирование на таймер TIM5
  TIM5::PSC::Write(8000U);                         // устанавливаем делитель частоты для таймер

  RCC::AHB1ENR::GPIOCEN::Enable::Set();

  //Порт С перевести в режим вывода (С.6 С.7 С.8 С.9 - линии светодиодов)
  GPIOC::MODER::MODER6::Output::Set();
  GPIOC::MODER::MODER7::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
  userButton1.AddObserver(garland);

  for(;;)  // вечный цикл
  {
    userButton1.IsPressed() ;// Если кнопка нажата
    Delay(500); // в миллисекундах
    garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
  }
}
-------
== Вывод
Я научился работать с  системным таймером и таймером общего назначения TIM5 и даже без куба.


