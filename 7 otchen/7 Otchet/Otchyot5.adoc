---
title: Отчёт 5
---
:toc-title: Содержание
:toc:
[text-center]



 Выполнил студент группы КЭ-413
 Ульданов Данил

:imagesdir: MyFiveProjectImg
:figure-caption: Рисунок
:table-caption: Таблица
:stem:


== Регистр

* Существуют регистры общего назначения и специальные регистры.
Регистры общего назначения расположены
внутри ядра микроконтроллера(сверхбыстрая память).

* Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для
хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных)
или данных, необходимых для работы самого процессора.

* Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления
процессором и периферийными устройствами.

* Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый
бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным
параметром микроконтроллера.

=== Регистры общего назначения
С точки зрения прикладного программиста, процессор располагает 16-ю 32-разрядными регистрами общего
назначения (РОН, GPR), из которых три на деле имеют специальные функции:

* Оперативные регистры
* Вспомогательные регистры
* Специальные регистры

=== Оперативные регистры
Регистры *R0-R3*, *R12* являются оперативными(sratch) регистрами.
Любая функция может использовать эти
регистры по своему усмотрению и уничтожать содержимое этих регистров.
Т.е. когда мы создам переменные в функции, эти переменные помещаются в эти регистры.
При выходе же из этой функции регистры *R0-R3* и *R12* перезаписываются на другие значения.

Если функции нужны значения этих регистров после вызова другой функции, она должна сохранить их на
стеке, а после вызова восстановить.

=== Вспомогательные регистры
Регистры от *R4-R11* являются вспомогательными.
Любая функция должна сохранить их на входе, а при
выходе восстановить их значение.

=== Специальные регистры
* Регистр указателя на стек *R13/SP*, должен всегда указывать на последний элемент стека или ниже него.
* Регистр *R15/PC* есть программный счетчик.
* Регистр *R14/LR*, содержит адрес возврата функции.

==== Как вызывается функция?
Когда происходит вызов функции, то происходится сохранение вспомогательных регистров
в стек. Также в регистр LR помещается адрес откуда была выывана функция, а регистр
LR уже помещает в стект это знаение адреса.
При выходе же из функции, происходи восстановление значений из стека в регистры  *R4-R11*
и возврат к адресу, откуда ушли по адресу из регистра LR.


=== Регистр специального назачения
[#Register]
.Схематичное изображение регистра
image::Figure1.png[]
[.notes]
--
* Название регистра
--
* Адрес регистра обозначается 32-битным шестнадцатеричным числом.
* Тип доступа к ячейкам регистра.
* Длина - количество ячеек в одном регистре. Мы будем работать с 32-битными регистрами.
* Поле - набор ячеек регистра, отвечающих за работу одной из функции микроконтроллера
* Значение поля - есть пространство всех возможных величин, которые может принимать поле

[.notes]
--
Значение поля зависит от длины поля. Т.е. если поле имеет длину 2, то существует 4 возможные
значения поля (0,1,2,3). Так же как у регистра, у полей и значений полей есть режим доступа (чтение,
записать, чтение и запись)
--

=== Пример регистра специального назначения
[.notes]
--
Как было сказано выше регистры используются для управления микроконтроллером и его периферией.
Например, чтобы запустить таймер 1 на счет, необходимо в Таймере1, в регистре *CR1(Control Register1)*
в поле *CEN(Counter Enable)* установить значение 1 (Enable).
--

[#RegisterCR1]
.Регистр CR1 Таймера 1
image::Figure2.png[800, 800]

  Бит 0 CEN: Включить счетчик
      0: Счетчик включен: Disable
      1: Счетчик выключен: Enable

Здесь, например, CEN — это поле размером 1 бит имеющее смещение 0 относительно начала регистра.
А Enable(1) и Disable(0) это его возможные значения.


=== Доступ к регистру специального назначения
Так как регистр специального назначения - это просто адресуемая ячейка памяти, то в коде это может
мы можем обратиться к данным по этому адресу, разыменовывая указатель, указывающий на этот адрес:
[source, cpp]

----
int main()
{
  *reinterpret_cast<uint32_t *>(0x40010000) |= 1 << 0 ; # <1>
  TIM1::CR1::CEN::Enable::Set() ;                       # <2>
}
----
<1> Записываем 1 в нулевой бит ячейки памяти (регистра) по адресу 0x40010000
<2> Тоже самое, но с использованием специального класса (обёртки) на С++

=== Работа с регистрами периферии через обертку на С++
[.notes]
--
Для того, чтобы настроить определенное периферийное устройство процессора, необходимо изменить
значение поля соответствующем регистре.

Для более удобной работы с регистрами можно использовать С++ обертку. Эта обертка позволяет обращаться
к регистрам в форме очень похоже с тем, как эти регистры описаны в документации.

Так, например, для запуска внешнего источника частоты, необходимо обратиться к регистру “CR”
периферии “RCC”, полю "HSEON" и установить в нем значение Enable.
Операция обращения к регистру выглядит следующим образом:
--

[source, cpp]

---
int main()
{
  RCC::CR::HSEON::Enable::Set() ;
}
---

[#RCC::CR]
.Подсказка для регистра CR модуля периферии RCC
image::Figure9.png[]

=== Некоторые моменты при работе с оберткой С++ для регистров

[.notes]
--

Для того, чтобы найти место где объявляется значение поля, необходимо правой мышкой нажать на значении
и найти все его объявления.
--

[#RCC::CR]
.Поиск места объявления значения
image::Figure10.png[]

[.notes]
--
На самом деле, все значения полей определены в файлах, которые лежат в папке:
AbstractHardware\Registers\STM32F411\FieldValues

Можно открыть файл с именем [имя периферии]filedvalues.hpp и найти там структуру названием
ИМЯ ПЕРИФЕРИ_ИМЯ РЕГИСТРА_ИМЯ ПОЛЯ_Values.

Например, для значений поля HSEON модуля периферии RCC, регистра CR, необходимо:
--

. открыть файл AbstractHardware\Registers\STM32F411\FieldValues\rccfieldvalues.hpp,
. найти структуру struct RCC_CR_HSEON_Values
. поменять в этой структуре *Value0* на *Disable*, а *Value1* на *Enable*.

== Операторы

* Арифметические операторы
* Операторы сравнения
* Логические операторы
* Побитовые операторы

[.notes]
--
Все операторы можно переопределить
--

=== Арифметические операторы
[.notes]
--
Арифметические операторы предоставляют базовые арифметические действия над типами, такие как
сложение, вычитание, деление, умножение, остаток от деления, присваивание. Любой оператор
может быть определен для множества пользовательского типа. Т.е. вы можете создать свой тип и определить
арифметические операторы для вашего типа. Например, можно определить арифметические операторы для
множества комплексных чисел, которые могут быть представлены в виде вашего собственного
пользовательского типа.
--

[#Арифметические операторы]
.Арифметические операторы
[options="header"]
[cols="4,4,4,8"]
|=====================
|Операция | Оператор | Комментарий | Описание
|Присваивание       | =     | a = b | Для бинарного оператора = выражение составного присваивания в форме
|Сложение           | +     | a + b | Бинарный оператор + возвращает сумму двух операндов, если они числовые.
|Вычитание          | -     | a - b | Бинарный оператор - возвращает разность двух операндов, если они числовые.
|Унарный плюс       | +     | +a | Унарный оператор + возвращает значение полученного операнда.
|Унарный минус      | -     | -a | Унарный оператор - изменяет знак операнда на противоположный.
|Умножение          | *     | a * b | Оператор умножения * вычисляет произведение операндов:
|Деление            | /     | a / b | Оператор деления / делит левый операнд на правый.
|Остаток от деления | %     | a % b | Оператор остатка % вычисляет остаток от деления левого операнда на правый.
|Инкремет  (пост и предфиксный)| ++      | &#43;&#43;a  и  a&#43;&#43;  | Увеличивет переменную на еденицу
|Декремент (пост и предфиксный)| - -     | --a и a--  | Уменьшает переменную на еденицу
|=====================

=== Логические операторы
[.notes]
--
Логические операторы предоставляют действия над булевым типов. Результат действия этих операторов
может быть только *true* или *false*
--
[#Логические операторы]
.Логические операторы
[options="header"]
[cols="4,4,4,8"]
|=====================
|Операция | Оператор | Комментарий | Описание
|Логическое отрицание, НЕ   | !     | !a    | Унарный префиксный оператор ! выполняет логическое отрицание операнда, возвращая true, если операнд имеет значение false, и false, если операнд имеет значение true.
|Логическое умножение, И    | &&    | a && b| Оператор & вычисляет логическое И для всех своих операндов. Результат операции x & y принимает значение true, если оба оператора x и y имеют значение true. В противном случае результат будет false.
|Логическое сложение, ИЛИ   | &#124;&#124;  |   a &#124; &#124;  b  | Оператор ^ вычисляет логическое исключение ИЛИ для всех своих операндов, возвращая true для x ^ y, если x имеет значение true и y имеет значение false или x имеет значение false и y имеет значение true.
|=====================

=== Побитовые операторы
[.notes]
--
Побитовые операторы предоставляют действия с битами.
--

[#Побитовые операторы]
.Побитовые операторы
[options="header"]
[cols="4,4,4, 8"]
|=====================
|Операция | Оператор  | Комментарий    | Описание
|Побитовая инверсия   | ~     | ~a    | Инвертирует биты (т.е. заменяет нули на единицы и наоборот)
|Побитовое И          | &     | a & b   | Позволяет сбрасывать биты в 0
|Побитовое ИЛИ        | &#124;   | a &#124; b | Устанавливае 1 в заданные биты
|Побитовое исключающее ИЛИ  | ^   | a ^ b | Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.  Исключающее ИЛИ b равно 1, если только a=1 или только b=1, но не оба одновременно a=b=1.
|Побитовый сдвиг влево  | <<   | a << b | Умножение числа на 2 ^ b
|Побитовый сдвиг вправо | >>   | a >> b | Деление числа на 2 ^ b
|=====================

== Микроконтроллер ST32F411RE
Что есть в процессоре:

<1> Много источников тактирования.
<2> Спец система для перезагрузки процессора в случае его зависания.
<3> Подсчёт контрольной суммы.
<4> Контроллер прерывания.
<5> Интерфейс для отладки.
<6> Две шины (высокочастотная и для периферийных устройств).
<7> 512 кбайт памяти.
<8> 128 кбайт ОЗУ.
<9> АЦП для измерения температуры, напряжения.
<10> Куча таймеров.
<11> И периферия такие как Uart, usb.

[#Микроконтроллер]
.Функциональные блоки микроконтроллера STM32F411
image::Figure7.png[600, 600]

=== Ядро CortexM4

Ядро предназначено для несложных не больших задач (например используется в датчиках давления).
Для цифровых фильтраций и несложных задач ядро является достаточно быстрым.
[#Ядро CortexM4]
.Ядро CortexM4
image::Figure12.png[500, 500]

* Ядро Cortex построено по гарвардской архитектуре с разделением шины данных и кода. ​
* Ядро Cortex-М4 поддерживает 8/16/32-разрядные операции умножения, которые выполняются за 1 цикл (деление со знаком (SDIV) или без (UDIV) занимает от 2 до 12 тактов в зависимости от размера операндов​
* Ядро Cortex-М4 поддерживает 8/16/32-разрядные операции умножения со сложением​

=== Характеристики микроконтроллера
[.notes]
--
Микроконтроллер имеет следующие характеристики:
--
[cols="a, a"]
|===
| *	32 разрядное ядро ARM Cortex-M4 | *	Блок работы с числами с плавающей точкой FPU
| *	512 кБайт памяти программ | *	128 кБайт ОЗУ
| * Встроенный 12 битный 16 канальный АЦП | *	DMA контроллер на 16 каналов
| *	USB 2.0 | *	3x USART
| * 5 x SPI/I2S | * 3x I2C
| * SDIO интерфейс для карт SD/MMC/eMMC | * Аппаратный подсчет контрольной суммы памяти программ CRC
| *	6 - 16 разрядных и 2 - 32 разрядных Таймера | *	1 - 16 битный для управления двигателями
| *	2  сторожевых таймера | *	1 системный таймер
| *	Работа на частотах до 100Мгц |* 81 портов ввода вывода
| *	Питание от 1.7 до 3.6 Вольт | * Потребление 100 мкА/Мгц
|===

=== Блок диаграмма микроконтроллера
[.notes]
--
Блок схема микроконтроллера схематично изображена на рисунке <<Блок диаграмма микроконтроллера>>.
--
[#Блок диаграмма микроконтроллера]
.Блок диаграмма микроконтроллера
image::Figure8.png[500, 500]

=== Дополнительные особенности микроконтроллера
[.notes]
--
Из дополнительных особенностей, которые понадобятся для лабораторных работ следует выделить:
--

*	Настраиваемые источники тактовой частоты
*	Настраиваемые на различные функции порты
*	Внутренний температурный сенсор
*	Таймеры с настраиваемым модулем ШИМ
*	DMA для работы с модулями (SPI, UART, ADC… )
*	12 разрядный ADC последовательного приближения
*	Часы реального времени
*	Системный таймер и спец. прерывания для облегчения и ускорения  работы ОСРВ

== Система тактирования

[#Система тактирования]
.Система тактирования микроконтроллера STM32F411
image::Figure13.png[700, 700]

* Для формирования системной тактовой частоты SYSCLK могут использоваться 3 основных источника:​
 ** HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​
 ** HSE (high-speed external) — внешний высокочастотный генератор.​
 ** PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей,
    исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.
* Также имеются 2 вторичных источника тактового сигнала:​
 ** LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​
 ** LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц​


=== Модуль тактирования.
Модуль тактирования (Reset and Clock Control) RCC - это регистр управления частотой.
[.notes]
--
Clock Control register (CR​)
Как уже упоминалось, системная тактовая частота для серии "STM32F411" может быть до 100 МГц. Для ее
формирования используются 3 основных источника — HSI, HSE, PLL. Включение и выключение основных
генераторов производится через регистр RCC_CR — Clock Control register.

Значение по умолчанию: 0x0000 XX81:​
--
[#Регистр RC_CR]
image::Figure14.png[800, 700]

[horizontal]
Bit 24 PLLON::  Включить PLL. Этот бит устанавливается и скидывается программно, чтобы включить PLL.
 Бит не может быть скинут, если PLL уже используется как системная частота. ​
* *0*: ОТКЛЮЧИТЬ PLL *1*: ВКЛЮЧИТЬ PLL​
[horizontal]
Bit 16: HSEON:: Включить HSE. Этот бит устанавливается и скидывается программно.  Бит не может быть
скинут, если HSE уже используется как системная частота. ​
* *0*: ОТЛЮЧИТЬ HSE  *1*: ВКЛЮЧИТЬ HSE ​
[horizontal]
Bit 0: HSION:: Включить HSI. Этот бит устанавливается и скидывается программно. Очищается аппаратно
при входе в режим Stop или Standby.  Бит не может быть скинут, если HSI уже используется как системная частота. ​
* *0*: ВЫКЛЮЧИТЬ HSI *1*: ВКЛЮЧИТЬ HSI ​

Включим программно систему тактирования от внешнего генератора HSE

[source, cpp]
--
RCC::CR::HSEON::On::Set();
--

=== Регистр управления частотой. Контроль
[.notes]
--
Сразу после установки частоты, нужно проверить, что частота с нового источника стабилизировалась. Для
этого используются те же поля того же регистра CR, оканчивающиеся на RDY (Ready)
--

[#Регистр RC_CR]
image::Figure14.png[600, 600]

[horizontal]
Bit 25 PLLRDY:: Флаг готовности частоты PLL. Этот бит устанавливается аппаратно ​
* *0*: PLL НЕ  ЗАПУЩЕН И  НЕ ИСПОЛЬЗУЕТСЯ *1*: PLL ИСПОЛЬЗУЕТСЯ​

[horizontal]
Bit 17: HSERDY:: Флаг готовности частоты  HSE. Этот бит устанавливается аппаратно. ​
* *0*: HSE НЕ ГОТОВ *1*: HSE ГОТОВ​

[horizontal]
Bit 1: HSIRDY:: Флаг готовности частоты  HSI. Этот бит устанавливается аппаратно​
* *0*: HSI НЕ ГОТОВ *1*: HSI ГОТОВ ​

Пример реализации в коде:

[source, cpp]
--
RCC::CR::HSEON::On::Set(); // Включаем внешний генератор,
while (RCC::CR::HSERDY::NotReady::IsSet())  {} // Дожидаемся переключения на внешний генератор
--

=== Регистр конфигурации частоты. Выбор источника
[.notes]
--
После включения генераторов частоты, необходимо выбрать один из них в качестве источника для системной
частоты SYSCLK. Выбор осуществляется через регистр RCC_CFGR — Clock Configuration Register.
Значение по умолчанию: 0x0000 0000​
--
[#Регистр RC_CR]
image::Figure14.png[600, 600]

[horizontal]
Bits 3:2 SWS[1:0]:: Статус частоты SYSCLK. ​
* *00*: ИСТОЧНИК ЧАСТОТЫ HSI *01*: ИСТОЧНИК ЧАСТОТЫ HSE
* *10*: ИСТОЧНИК ЧАСТОТЫ PLL *11*:  РЕЗЕРВ​

[horizontal]
Bits 1:0 SW[1:0]:: Выбор источника частоты SYSCLK. ​
* *00*: HSI  *01*: HSE
* *10*: PLL  *11*: НЕ ИСПОЛЬЗУЕТСЯ

Пример переключения на внешний генератор с отключением внутреннего:

[source, cpp]
--
RCC::CR::HSEON::On::Set(); // Включаем внешний генератор,
while (RCC::CR::HSERDY::NotReady::IsSet())  {} // Дожидаемся переключения на внешний генератор
RCC::CFGR::SW::Hse::Set(); // Переключатель для переключения между генераторами (внешним (Hse), внутренним (Hsi) и PLL)
while (!RCC::CFGR::SWS::Hse::IsSet())  {} // что мы точно переключились на внешний генератор
RCC::CR::HSION::Off::Set(); //  Отключение внутриннего генератора (тольки при включенных других генераторах)
--
=== Регистр конфигурации частоты. Делители

Следующие секции регистра HPRE (AHB prescaler), PPRE1 (APB1 prescaler), PPRE2 (APB2 prescaler) —
задают коэффициенты деления системной частоты SYSCLK, которая после предделителей поступает на
матрицы шин. ​

[.notes]
--
[horizontal]
AHB (Advanced High Speed Busses):: матрица высокоскоростных шин. Она "доставляет" сигналы
тактирования к ядру микроконтроллера, памяти (это как FLASH, так EEPROM и RAM) и модулю DMA
Direct Memory Access — модуль прямого доступа к памяти), системному таймеру. Также, в семействе
STM32F4 на эту шину "посажены" и все порты ввода/вывода GPIO .

[horizontal]
APB1, APB2 (Advanced Peripheral Bussess):: матрицы шин периферии. Соотвественно, к остальным
периферийным модулям тактовая частота распределяется уже через эти шины. ​
--

[#Регистр RC_CR]
image::Figure14.png[600, 600]

[horizontal]
Bits 13:11 PPRE2[2:0]:: Делитель частоты шины APB2. Это устанавливается и очищается программно. ​
* *0xx*: AHB      *100*: AHB/2     *101*: AHB/4     *110*: AHB/8    *111*: AHB/16 ​

[horizontal]
Bits 10:8 PPRE1[2:0]:: Делитель частоты шины APB1 Это устанавливается и очищается программно. ​
* *0xx*: AHB     *100*: AHB/2      *101*: AHB/4     *110*: AHB/8     *111*: AHB/16​

[horizontal]
Bits 7:4 HPRE[3:0]:: Делитель частоты шины AHB. ​
* *0xxx*: SYSCLK    *1000*: SYSCLK/2     *1001*: SYSCLK/4     *1010*: SYSCLK/8     *1011*: SYSCLK/16
    ​
  *1100*: SYSCLK/64  *1101*: SYSCLK/128  *1110*: SYSCLK/256   *1111*: SYSCLK/512​


=== Алгоритм настройки частоты​
* Определить какие источники частоты нужны​
  ** Например, PLL нужен для USB​

* Включить нужный источник​
** Используя Clock Control register (RCC::CR)​

* Дождаться стабилизации источника ​
** Используя соответствующие биты (..RDY) Clock Control register ​(RCC::CR)

* Назначить нужный источник на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

* Дождаться пока источник не переключиться на системную частоту​
** Используя Clock Configuration Register (RCC::CFGR)​

== Домашнее задание
Переключение тактирования на PLL и мигание светодиодом от частоты в 32 МГц:
Рассчитаем значения делителей c помощью следующих формул, приведённых в документации на STM32F411.

image::Formylu.jpg[400]

Ниже представлена схема тактирования для выполнения домашнего задания  нам понадобится для расчётов один блок PLL.
Необходимо рассчитать делители и устанновить SW в тактирование от PLL.

image::Sxema.jpg[800]

Согласно формулам выше расчитаем делители и получим: M=8 P=6 Q=4 N=96 VCO=2

image::Rezyltat.png[800]

Теперь, переведём всё в код:

[source, cpp]
--
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
int32_t zaderzka = 1000000; // Переменная для времени задержки
//------Переменные делителей-------------
uint8_t PLL_M = 8;
uint8_t PLL_N = 96;
uint8_t PLL_P = 0x02; // 0x00 - 2; 0x01 - 4; 0x02 - 6; 0x003 - 8
uint8_t PLL_Q = 4;
uint8_t PLL_SRC = 0; // Откуда берём тактирование от HSI=0 или HSE=1
//--------------------------------------
//-----------------------------Функция задержки----------------------------------
int delay(int value)
    {
        for(int i = 0;i<value;++i)
        {
            volatile int j = i;
        }
    }
//------------------------------------------------------------------------------
int main()
{
//-----------Конфигурация PLL-----------------------------------------
    RCC::PLLCFGR::Write(PLL_M << 0 |( PLL_N << 6)|(PLL_P << 16)|(PLL_SRC << 22) |(PLL_Q << 24));
//----------Включаем PLL и дожидаемся его готовности-------------------
    RCC::CR::PLLON::On::Set(); // Включаем генератор PLL
    while (!RCC::CR::PLLRDY::Locked::IsSet())  {}
//---------Переключаемся на PLL и дожидаемся его переключения-----------
    RCC::CFGR::SW::Pll::Set(); // Переключились на генератор PLL
    while (!RCC::CFGR::SWS::Pll::IsSet())  {} // Убеждаемся, что мы точно переключились на генератор PLL
//-------------Подаём тактирование на светодиод---------------------------
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    GPIOC::MODER::MODER7::Output::Set();
    while(true)
        {
            //----Светодиод светит----------
            delay(zaderzka);
            GPIOC::ODR::ODR7::High::Set();
            //----Светодиод не светит-------
            delay(zaderzka);
            GPIOC::ODR::ODR7::Low::Set();
        }
    return 1;
}
--
Результат:
Тактирование от внешнего генератора ( 8 МГц):

video::Clocking_HSE.mp4[]

Тактирование от внутреннего генератора ( 16 МГц):

video::Clocking_HSI.mp4[]

Тактирование от PLL генератора (32 МГц)

video::Clocking_PLL.mp4[]


== Вывод
Я научился переключаться между тремя генераторами тактовой частоты: внутренним (HSI),
внешним (HSЕ) и PLL.
Научился расчитывать делители и настраивать нужную частоту на выходе PLL.
Научился работать с регистрами и устанавливать в них необходимые значения бит.
Научился работать с документацией к плате STM32F411, в частности с регистрами тактирования.
