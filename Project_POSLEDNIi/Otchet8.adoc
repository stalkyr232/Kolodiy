---
title: Отчёт 8
---

:reproducible:

:description: Project_8
:keywords: AsciiDoc
:imagesdir: Project_8
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[.notes]
С++ - объекто-ориентированный язык программирования, это означает, что он
построен на классах и объектах. И в нём действуют 4 главных правила:

1. Абстракция. Это создание и описание объекта и его функци (методов).
2. Наследование. Это, когда созданный объект перенимает свойства родительского объекта.
3. Инкапсуляция. Это сокрытие от пользователя функционала объектов, на
основе которых состоит более сложный объект.
4. Полиморфизм. Это присваение двум наследникам одного класса разлиных
поведенческих функций (методов).


== Постановка задачи
Для того, чтобы написать правильно работающий код с возможностью
расширения функционала, необходимо продумать дизайн программы.
Продумка дизайна позволит писать код проще (т.е. строчки кода будут короче и читабельнее),
а также позволит адаптировать программу.

По заданию требуется написать программу "Гирлянда", которая может
управлять светодиодами, и по кнопке задавать 3 режима:

- мигание всеми светодиодами
- мигание светодиодами в шахматном порядке
- "Ёлочка"

Как уже было сказано, разработку программы стоит начинать с дизайна.
Для этих целей хорошо подойдёт UML диаграмма, котора позволит выстроить
логические цепочки.

Т.к. светодиоды у нас привязаны к пинам, то



.Создание нового проекта
image::CreateNewProject.png[width=500]

Далее создаём функцию main на языке С++ и выбираем путь куда сохраним новосозданный проект.

.Создание функции main на языке С++
image::Create_main.png[width=500]
--
Таким образом появился новый пустой проект.

.Новый проект
image::NewProject.png[width=500]
--
<<<
=== Работа с терминалом
Создадим первую программу:


[source, c]
#include <iostream>
int main()
{
    signed char i=127;
    i=i+1;
    std::cout<<(int)i << std::endl;
    return 0;
}

[.notes]
И, для того чтобы, просмотреть результат вывода воспользуемся терминалом. Для этого выберем View->Terminal I/O. Откроется терминал в котором будет результат:

.Результат вывода в терминал
image::Terminal.png[]

Как так, что прибавив 1 к 127 получили не 128 а отрицательное число?
Дело в том что char является одно байтовым числом, т.е. имеет 8 бит:

image::Calc.png[]

"signed" указывает на то что тип знаковый, т.е. если максимальное
значение типа char = 255, то знаковый char = 127, т.к. первый бит
выделяется под знак.
Таким образом, при прибавлении к 127 единицы получили, что первый
бит = 1, а все остальные нули.
Поскольку старший (знаковый) бит равен 1, то это означает, что число
отрицательное, что, в свою очередь, означает, что оно представлено в
дополнительном коде, поэтому сначала необходимо получить прямой код
числа. Для этого дополнительный код нужно проинвертировать и
прибавить "1". так получим числовое значение дополнительного кода:

image::RAAC.png[]

Т.о. корректное использование типов данных позволяет избегать ошибок.
[Типы данных]
.Типы данных
[options="header"]
|=====================
|Тип|Количество бит|Диапазон
|unsigned char (без знаковый)|8        |0...255
|signed char (знаковый)|8        |-128...127
|char16_t (символ в кодировке Unicode)|16               |0...65 535
|char32_t (символ в кодировке Unicode)|32               |0...4 294 967 295
|unsigned int (без знаковый)|В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита)|0...65 535 (для 2 байт), 0...4 294 967 295 (для 4 байт)
|signed int (знаковый)|В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита)               |–32 768...32767 (при 2 байтах) или от −2 147 483 648...2 147 483 647 (при 4 байтах)
|float (вещественное число ординарной точности с плавающей точкой)|32               |- 3.4E-38...3.4E+38
|double (вещественное число двойной точности с плавающей точкой)|64               |- 1.7E-308...1.7E+308
|=====================

=== Выбор контролера
Для того чтобы можно было загружать код в плату необходимо настроить проект под наш микроконтроллер. Для этого нажмём правой кнопкой мыши по проекту и выберем Options->General Options->Target.
Выберем "Device" ST STM32F411RC. На вкладке Debugger выберем Driver "ST-LINK". И на вкладке ST-LINK выберем "SWD".


image::STM32F411RC.png[]
image::ST_LINK.png[]
image::SWD.png[]

=== Подключение платы

Плату необходимо подключить через отладчик, ибо он перепрошивает микроконтроллер.

.Подключение платы через отладчик по USB
image::ConnectBoard.png[]

=== Первая программа на плате
Для проверки работоспособности платы загрузим код из stm32Labs->Lab1->iarproject.ewd.

[source, c++]
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ
std::uint32_t SystemCoreClock = 16'000'000U;
extern "C"
{
    int __low_level_init(void)
    {
        //Switch on external 16 MHz oscillator
        RCC::CR::HSION::On::Set();
        while (RCC::CR::HSIRDY::NotReady::IsSet())
        {
        }
        //Switch system clock on external oscillator
        RCC::CFGR::SW::Hsi::Set();
        while (!RCC::CFGR::SWS::Hsi::IsSet())
        {
        }
        RCC::APB2ENR::SYSCFGEN::Enable::Set();
        return 1;
    }
}
void delay(int cycles)
{
    for(int i = 0; i < cycles; ++i)
    {
        asm volatile("");
    }
}
int main()
{
    //Подать тактирование на порт А
    RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
    //Подать тактирование на порт С
    RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
    //Порт 5.А на вывод
    GPIOA::MODER::MODER5::Output::Set() ;
    //Порт С.5, С.8, С.9 на вывод
    GPIOC::MODER::MODER5::Output::Set() ;
    GPIOC::MODER::MODER8::Output::Set() ;
    GPIOC::MODER::MODER9::Output::Set() ;
    for(;;)
    {
        GPIOA::ODR::ODR5::High::Set();
        GPIOC::ODR::ODR8::High::Set();
        delay(1000000);
        GPIOA::ODR::ODR5::Low::Set();
        GPIOC::ODR::ODR8::Low::Set();
        delay(1000000);
    }
    return 1;
}

Этот код позволяет мигать светодиодом.


video::MiganieLED.mp4[]

=== _forceinline
_forceinline - это макрос, который позволяет не делать функцию
как реальную, т.е. обычно при вызове функции компилятор идёт
внутрь этой функции и выполняет действия содержащиеся в ней.
Функция Set() из кода выше описывается функцией, которая находится
в файле "fieldvaluebase.hpp".
И для того, чтобы при отладке вместо функции Set() компилятор
не вставлял содержимое этой функции и прописывается данный макрос.
Этот макрос позволяет экономить ПЗУ.

== Вывод
Я научилась подключать плату к ноутбуку, настраивать среду
разработки в IAR, запускать отладчик, клонировать репозитории из гитхаба.
>>>>>>> dd41c8f31af8845b72ebcb1cc09e39e9ec954adc

