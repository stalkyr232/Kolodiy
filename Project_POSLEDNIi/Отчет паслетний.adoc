---
title: Отчёт 8
---

[text-right]
--
 Выполнил студент группы КЭ-413
 Ульданов Данил
--

:reproducible:

:description: Project_8
:keywords: AsciiDoc
:imagesdir: Image
:figure-caption: Рисунок
:table-caption: Таблица


:toc-title: Содержание
:toc:

[.notes]
Язык программирования С++ является объекто-ориентированным (ООП) языком, это означает, что данный язык построен на
классах и объектах. А все ООП имеют 4 столпа:

1. Абстракция - создание и описание объекта и его функций (методов).
2. Наследование - перенимание дочерними объектами свойств, присущих родительскому объекту.
3. Инкапсуляция - сокрытие от пользователя часть функционирования объекта.
4. Полиморфизм - присваение двум разным объектам одних и тех же поведенческих функций.

== Постановка задачи
Необходимо написать программы *Гирлянда*, которая могла бы управлять светодиодами и при нажатии на кнопку переключать режимы.

Для реализации программы необходимо разработать её дизайн с помощью UML-диаграммы.

В гирлянде наметим 5 абстракций:

- пины (Pin)
- кнопки (Button)
- светодиоды (LED)
- режимы (IMode)
- гирлянда (Garland)

Другими словами, мы должны подключить пины к светодиодам и кнопке, затем по нажатию кнопки переключать режимы по кругу.
Для этого сперва опишем внутренние составляющие гирлянды (пины), затем светодиоды и кнопку, затем режимы и в конце саму гирлянду.

=== Пины

Т.к. абстракция  *Pin* привязан к порту, то для того чтобы была возможность передавать в эту абстракцию любой порт
(GPIOA, GPIOB, GPIOC и т.д.) с любым номером порта, создадим шаблонный класс, в который и будем передавать порт и номер порта.

Таким образом мы создаём класс *pin* и два интерфейса от которых будет наследоваться пин:

- *IPinReadable*, который будет наследоваться пином, отвечающим за кнопку.
- *IPin*, который будет наследоваться пином, отвечающим за светодиод.

В этих интерфейсах функции нереализуются, а только объвляются, поэтому данные функции будут виртуальными *virtual*.
Вся реализация этих функций описывается в заголовочном файле *pin.h*.

.Создание класса *Pin* и интерфейсов *IPinReadable* и *IPin*
image::Создание объекта Pin с интерфейсами .png[]

Интерфейс *IPin* в себе содержит объявления функций, которые необходимы для работы с пинами светодиодов:

- функция Reset - позволяет выключить пин (сбросить пин в 0);
- функция Toggle - позволит переключить состояние пина на противоположное.

Данные функции являются публичными *public*, т.к. могут вызываться другими функциями из других частей программы.
Для того чтобы внутри этих функций никакие атрибуты не изменялись используем *const = 0*, проще говоря, мы не можем изменить переменные внутри константной функции.
Константная функция (const) применяется только в том случае, если внутри этой функции не будет изменяющихся атрибутов (переменных).

.Интерфейс ipin.h
[source, c++]
-------
// Интерфейс класса Pin для светодиодов
#ifndef IPIN_H //Защита от двойного подключения заголовочного файла
#define IPIN_H //Защита от двойного подключения заголовочного файла

class IPin
{
public: // Публичные методы, которые могут вызываться из любого места программы
  virtual void Reset() const=0;    //  Сбрасывает пин в 0
  virtual void Toggle() const=0 ; //   Переключает пин в противоположное состояние
};
#endif //Защита от двойного подключения заголовочного файла
-------
Интерфейс *IPinReadable* в себе содержит объявления функций, которые необходимы для работы с пинами кнопки:

- функция IsHigh - Возвращает состояние пина.

.Интерфейс IPinReadable.h
[source, c++]
-------
// Интерфейс класса Pin для кнопки
#ifndef IPINREADABLE_H
#define IPINREADABLE_H

class IPinReadable
{
public:
  virtual bool IsHigh() const=0; // позволяет считать состояние ножки
};
#endif
-------

Заголовочный файл *Pin.h* содержит в себе описание всех функций, которые необходимы для работы с пинами:

- функция Set() - устанавливает пин в 1; Функция не возвращает значение, поэтому является типом *void*. Функция не изменяет своих атрибутов, поэтому является константной *const*;
- функция Reset() - выключает пин (сбросывает пин в 0). Функция переопределяется *override*, т.к. присутствует в других частях программы;
- функция Toggle() - переключает состояние пина на противоположное;
- функция IsHigh() - считывает состояние пина.

.Класс pin.h
[source, c++]
-------
#ifndef PIN_H
#define PIN_H

#include "ipin.h" // подключение интерфейса пина для светодиодов
#include "IPinReadable.h" // подключение интерфейса пина для кнопки

template<typename TPort, int pinNum> // Шаблон класса для помещения в него любого порта (GPIOC, GPIOА) и любого номера этого порта
class Pin: public IPin, public IPinReadable // Наследование
{
public: // Публичные методы (методы доступные всем)
  void Set() const
  {
    TPort::ODR::Set(1U << pinNum); // Передали порт и установили его значение в 1
  }

  void Reset() const override
  {
    auto value = TPort::ODR::Get(); // Получение состояния регистра порта
    value &=~(1U << pinNum);        // Сброс 1 бита
    TPort::ODR::Write(value);       // Запись 0 в регистр порта
  }

  void Toggle() const override
  {
    TPort::ODR::Toggle(1U << pinNum); // Переключили состояние порта на противоположное
  }

  bool IsHigh() const override
  {
    auto value = TPort::IDR::Get(); //Получение состояния входного регистра
    return ( (value & (1U << pinNum) ) == (1 << pinNum) ); // Проверка на единичный бит
  }
};
#endif
-------
Таким образом была сделана абстракция для пина, котоая привязывается к конкретному порту и к конкретному номеру ножки.

=== Светодиоды

Т.к. абстракция  *LED* привязана к порту (ножке) процессора, поэтому при создании объекта типа LED передадим объкту LED ножку порта к которой светодиод привязан.

Таким образом мы создаём класс *LED* и интерфейс *ILED* от которого будет наследоваться светодиод.

В интерфейсе *ILED* функции нереализуются, а только объвляются, поэтому функции будут виртуальными *virtual*.
Вся реализация этих функций описывается в исполнительном файле *LED.срр*.

.Создание объекта LED с интерфейсом ILED
image::Создание  LED с интерфейсом ILED.PNG[]

Интерфейс *ILED* содержит в себе виртуальные функции, которые необходимы для работы со светодиодами:

- функция Toggle() - переключает состояние светодиода на противоположное. Функция не возвращается значение и не имеет изменяющихся атрибутов.
- функция SwithOff() - позволяет выключить светодиод.

.Интерфейс ILED.h
[source, c++]
-------
//Интерфейс класса Led
#ifndef ILED_H
#define ILED_H

class ILed
{
public:
  virtual void SwithOff() const=0;  // Виртуальный метод выключения светодиода.
  virtual void Toggle() const=0;    // Виртуальный метод переключения светодиода в противоположное состояние.
};
#endif
-------

В интерфейсе функции нереализуются, а только объвляются. Вся реализация этих функций описывается в файле *LED.cpp*.

.Заголовочный файл LED.h
[source, c++]
-------
#ifndef  LED_H
#define  LED_H

#include "ILED.h" // подключение интерфейса светодиода
#include "ipin.h" // подклчение интерфейса пина

class Led : public ILed // наследование LED от интерфейса ILED
{
public:
   Led(const IPin& pin) ; // конструктор в который передаётся ссылка на класс типа IPin

//----------Переопределяются, т.к. они уже есть в интерфейсе--------------------
   void SwithOff() const override; // Переопределяемый метод выключение светодиода
   void Toggle() const override;   // Переобпределяемый метод переключение светодиода
//------------------------------------------------------------------------------

private: // приватный атрибут, который хранит ссылку на интерфейс (его инициализация находится в LED.cpp)
    const IPin& _pin;
};
#endif
-------

.Исполняемый файл LED.сpp
[source, c++]
-------
#include "LED.h" // подключение заголовочного файла LED
Led::Led(const IPin& pin): _pin(pin) // инициализация ссылки на объект IPin
{

}
// потушить светодиод
void Led::SwithOff() const
{
  _pin.Reset(); // у IPin есть метод Reset(), который сбрасывает пин в 0
}

// переключить светодиод
void Led::Toggle() const
{
  _pin.Toggle(); // у IPin есть метод Toggle(), который переключает пин из одного состояния в противоположное
}
-------

=== Кнопка

Абстракция  *Button* привязана к порту так же как и светодиод,поэтому по аналогии со светодиодом, создадим класс *Button* и интерфейс от которых будет наследоваться кнопка:

.Создание объекта Button и его интерфейса
image::Создание кнопки.PNG[]

Интерфейс *IButton* содержит в себе функции, которые необходимы для работы с кнопками:

- функция IsPressed - показывает состояние кнопки (Нажата / не нажата).

.Интерфейс IButton.h
[source, c++]
-------
//Интерфейс класса кнопки
#ifndef IBUTTON_H
#define IBUTTON_H

class IButton
{
public:
  virtual bool IsPressed() const=0;
};
#endif
-------

.Заголовочный файл Button.h
[source, c++]
-------
#ifndef  BUTTON_H
#define  BUTTON_H

#include "IButton.h" // Подключение интерфейса Button
#include "iPinReadable.h" // Подключение интерфейса считывания

class Button : public IButton // наследование Button от интерфейса IButton
{
public:
  Button(const IPinReadable& pin) ;
  bool IsPressed() const override;

private:
    const IPinReadable& _pin;
};
#endif
-------
В интерфейсе функции нереализуются, а только объвляются. Вся реализация этих функций описывается в файле *Button.cpp*.

.Класс Button.сpp
[source, c++]
-------
#include "Button.h" // подключение заголовочного файла Button

Button::Button(const IPinReadable& pin): _pin(pin)
{

}
bool Button::IsPressed() const
{
    if( !_pin.IsHigh() )  // Если кнопка не нажата
    {
        while (!_pin.IsHigh()) // Если в какой-то момент времени кнопка нажалась, то режим меняем
        {
           volatile int a = 1; // ничего не делающая строчка, нужна для ожидания пока кнопка обратно не отпустится
        }
        return true;
    }
    return false;
}
-------

Затем создами *pinconfig.h* для того, чтобы здесь задавать привязку к пинам.
Чтобы светодиоды были привязаны только к абстрактному классу, а не к выводам микроконтроллера непосредственно.
Аналогично создадим и для кнопки.

.Класс pinconfig.h
[source, c++]
-------
#ifndef  PINCONFIG_H
#define  PINCONFIG_H

#include "pin.h"

//-----------------------------Светодиоды---------------------------------------
inline constexpr Pin<GPIOC, 5> pinC5;
inline constexpr Pin<GPIOC, 8> pinC8;
inline constexpr Pin<GPIOC, 9> pinC9;
inline constexpr Pin<GPIOA, 5> pinA5;
//------------------------------------------------------------------------------

inline constexpr Pin<GPIOC, 13> pinC13; // кнопка
#endif
-------

=== Режимы

Гирлянда подразумевает в себе 4 режима:

- Мигалка
- Шахматы
- Ёлочка
- Горка

Все режимы объединяет интерфейс *IMode*, который должен реализовывать 2 функции:

- Update() - обновляет светодиоды в гирлянде. Метод будет не константным, так как будут присутствовать изменяющиеся атрибуты;
- Clear() - очистка светодиодов (сброс их в начальное состояние). Данный метод тоже не будет константным.

.Создание режимов
image::Создание режимов.PNG[]

.Интерфейс IMode.h
[source, c++]
-------
//Интерфейс для различных режимов
#ifndef IMODE_H
#define IMODE_H

#include <array>   // подключение библиотеки массивов
#include "ILED.h" // подключение интерфейса LED

using tArrayLeds = std::array<ILed*,4>;

class IMode
{
public:
  IMode(const tArrayLeds& leds): _leds(leds)
  {

  }
  virtual void Update() const
  {
     for(auto& it:_leds) // Весь массив из светодиодов
     {
        it->Toggle(); // Переключает светодиоды из одного состояния в другое
     }
  };

  virtual void Clear() const
  {
    for(auto& it:_leds)
    {
       it->SwithOff(); // Выключает каждый светодиод из массива светодиодов
    }
  };

protected:
   const tArrayLeds& _leds; // массив из светодиодов может использоваться только классами наследниками
};
#endif
-------

В данном интерфейсе функции и объявляются и реализуются.

Далее на каждый режим будут сосданы по 2 файла: заголовочный и исполнительный.

==== Мигалка
Опишем режим *AllMode*, который должен просто моргать всеми светодиодами.
Мигание заключается в том, что весь массив светодиодов зажигается и весь гасится.
Для этого режима достаточно использовать методы родителя *IMode*, лишь передав в режим массив из светодиодов.

.Заголовочный файл AllMode.h
[source, c++]
-------
//заголовочный файл для режима "Моргалка"
#ifndef ALLMODE_H
#define ALLMODE_H

#include "IMode.h" // Подключение интерфейса IMode
#include "iled.h" // Подключение интерфейса LED

class AllMode: public IMode // Наследование режима моргания от интерфейса IMode
{
public:
   AllMode(const tArrayLeds& leds) ; // Передача светодиодов в режим моргалки
};
#endif
-------

.Исполняемый файл AllMode.сpp
[source, c++]
-------
#include "AllMode.h" // Подключение заголовочника

AllMode::AllMode(const tArrayLeds& leds): IMode(leds) // Наследование всех функций (методов) он интерфейса IMode
{
  
}
-------

==== Шахматы
Далее опишем режим *ChessMode*, который должен моргать светодиодами в шахматном порядке.
Для данного методы необходимо переопределить функцию Clear() *override*.

.Заголовочный файл ChessMode.h
[source, c++]
-------
//заголовочный файл для режима "Шахматы"
#ifndef CHESSMODE_H
#define CHESSMODE_H

#include "IMode.h" // Подключение инерфейса IMode
#include  "ILED.h" // Подключение интерфейса LED

class ChessMode: public IMode // Наследование режима шахматы от интерфейса IMode
{
public:
   ChessMode(const tArrayLeds& led) ; // Передача светодиодов в режим шахмат
   void Clear() const override ;      // Переопределённая функция выключения светодиодов
};
#endif
-------

.Исполняемый файл ChessMode.сpp
[source, c++]
-------
#include "ChessMode.h" // Подключение заголовочника

ChessMode::ChessMode(const tArrayLeds& leds): IMode(leds) // Наследование всех функций от интерфейса IMode
{
  Clear(); // Вызов переопределённой функции
}

void ChessMode::Clear() const // реализация переопределённой функции
{
    for (std::uint32_t i = 0; i < std::size(_leds); ++i) // Пока не пройдём весь массив светодиодов
    {
      if ((i % 2) == 0) // Проверка на чётность
      {
         _leds[i]->Toggle(); // переключаем в противоположное состояние чётные светодиоды
      }
    }
}
-------
==== Ёлочка
Далее опишем режим *TreeMode*, который должен зажигать светодиоды по порядку от первого к последнему, а затем тушить их так же.

.Заголовочный файл TreeMode.h
[source, c++]
-------
//заголовочный файл для режима "Ёлочка"
#ifndef TREEMODE_H
#define TREEMODE_H

#include "IMode.h"
#include  "Iled.h"

class TreeMode: public IMode
{
public:
   TreeMode(const tArrayLeds& led) ; // Передача массива из светодиодав
   void Update() override ;  // Переопределение функции

private:
  uint32_t ledNumber = 0; // Индекс светодиода
};
#endif
-------

.Исполняемый файл TreeMode.сpp
[source, c++]
-------
#include "TreeMode.h"

TreeMode::TreeMode(const tArrayLeds& leds): IMode(leds)
{
  Clear();  // нужна для сброса всех светодиодов в 0 в начальный момент переклчения на данный режим
}

void TreeMode::Update()
{
  _leds[ledNumber]->Toggle();  // переключаем светодиод на противоположное состояние
  if(ledNumber == (size(_leds)-1)) // если дошли до конца массива светодиодов
  {
      ledNumber = 0; // то начинаем с начала
  }
  else
  {
      ledNumber++; // иначе переходим к следующему светодиоду
  }
}
-------
==== Горка
Опишем режим *SlideMode*, который должен зажигать сперва два крайних светодиоды, затем второй от начала и с конца и т.д. и тушить их также попарно, как зажигались, но в обратном порядке.

.Заголовочный файл SlideMode.h
[source, c++]
-------
//заголовочный файл для режима "Горка"
#ifndef SLIDEMODE_H
#define SLIDEMODE_H

#include "IMode.h" // Подключение инерфейса IMode
#include  "ILED.h" // Подключение интерфейса LED

class SlideMode: public IMode // Наследование режима горки от интерфейса IMode
{
public:
   SlideMode(const tArrayLeds& led) ; // передача светодиодов в режим горки
   void Update() override ;

private:
  uint32_t ledNumber = 0;  //  индекс светодиода
  bool revers = false;    // Флаг, отвечающий за прямое и обратное зажигание светодиодов
};
#endif
-------

.Исполняемый файл SlideMode.сpp
[source, c++]
-------
#include "SlideMode.h" // подключение заголовочника режима горки

SlideMode::SlideMode(const tArrayLeds& leds): IMode(leds) // Наследование всех функций (методов) от интерфейса IMode
{
  Clear();  // Сброс светодиодов в начальное состояние
}

void SlideMode::Update()  // Реализация переопределённой функции
{
  _leds[ledNumber]->Toggle(); // Переключение светодиода (от начала) в противоположное состояние
  if (ledNumber != (size(_leds) - 1 - ledNumber)) // Если номера светодиодов не пересеклись
  {
    _leds[size(_leds) - 1 - ledNumber]->Toggle(); // то переключаем состояние светодиода с конца на противоположное
  }

  if (!revers) // Если прямой ход
  {
     if(ledNumber < ( ((size(_leds) + 1) / 2) -1 ) ) // Если индекс светодиода не дошёл до середины
     {
        ledNumber ++ ; // то прибавляем индекс светодиода
     }
     else
     {
       revers = true; // иначе идём в обратном порядке
     }
  }
  else  // Иначе обратный ход
  {
     if(ledNumber > 0) // Если индекс светодиода от начала больше 0
     {
        ledNumber --; //  идём в обратном порядке и отнимаем индекс светодиода
     }
     else // иначе
     {
       revers = false; // как только индекс светодиода стал = 0, переходим в прямой ход
     }
  }
}
-------

=== Гирлянда
Гирлянда управляет режимами, а значит должна уметь переключать режимы и обновлять состояние текущего режима.

- UpdateCurrentMode() - обновляет состояние текущего режима.
- SwithNextMode() - переключает режим на следующий.

.Создание объекта Garland
image::Создание гирлянды.png[]

.Заголовочный файл Garland.h
[source, c++]
-------
//Интерфейс для различных режимов
#ifndef GARLAND_H
#define GARLAND_H

#include <array>    // Подключение библиотеки массивов
#include "IMode.h" // Подключение интерфейса

using tArrayModes = std::array<IMode*, 4>; // Передача массива из режима
class Garland
{
public:
  Garland(const tArrayModes& modes): _modes(modes) // Инициализация ссылки на массив режимов
  {

  }

  void UpdateCurrentMode() const
  {
     _modes[modeNumber]->Update(); // Обновляет состояние светодиодов в текущем режиме
  };

  void SwithNextMode()
  {
    if (modeNumber == (_modes.size()-1)) // Если номер режима = последнему режиму,
    {
      modeNumber = 0; // то номер режима скидываем в ноль и начинаем заново (гоняем по кругу режимы)
    }
    else // Иначе
    {
      modeNumber ++; // переключаемся на следующий режим
    }
    _modes[modeNumber]->Clear(); // Сброс всех светодиодов
  };

private:
   uint32_t modeNumber = 0;    // Счётчик режимов
   const tArrayModes& _modes;  // Массив из режимов
};
#endif
-------

=== Исполнительный файл Main.cpp
И напишем код в main.cpp. Подключим необходимые заголовочники и создадим объекты:
светодиоды, кнопка, режимы и гирлянда.

.Главный файл main.сpp
[source, c++]
-------
#include "rccregisters.hpp" // Для модуля RCC
#include "gpiocregisters.hpp" // регистр для порта с
#include "gpioaregisters.hpp" // регистр для порта a

#include "pinconfig.h" // подкючение привязанных пинов к портам МК
#include "LED.h"   // подключение заголовочного файла
#include  "Button.h" // для кнопки
#include "AllMode.h" // режим горят все
#include "ChessMode.h" // режим шахматы
#include "TreeMode.h" // режим ёлочка
#include "SlideMode.h" // режим горочка
#include "Garland.h" // гирлянда

#include <iostream> // подключение стандартной библиотеки С++
#include <array> // подключение библиотек для работы с массивами
// -------------------------Функция задержки-----------------------------------
void Delay(uint64_t value)
{
  for(uint64_t i = 0;i<value;++i)
  {
    volatile uint64_t j = i;
  }
}
//------------------------------------------------------------------------------

//-------Создание объектов (компонентов гирлянды) с привязкой к пинам-----------
Led led1(pinA5); // светодиод 1
Led led2(pinC9); // светодиод 2
Led led3(pinC8); // светодиод 3
Led led4(pinC5); // светодиод 4
Button userButton1(pinC13); // кнопка
//------------------------------------------------------------------------------

//---------------------------------Массива из светодиодов-----------------------
    tArrayLeds leds =
    {
      &led1,
      &led2,
      &led3,
      &led4,
    };
//------------------------------------------------------------------------------

//-------------Создание объектов (режимов) с массивом из светодиодов------------
  AllMode allMode(leds);
  ChessMode chessMode(leds);
  TreeMode treeMode(leds);
  SlideMode slideMode(leds);
//------------------------------------------------------------------------------

//----------------------------------Массив из режимов--------------------------
    using tArrayModes = std::array<IMode*,4>;
    tArrayModes modes =
    {
      &allMode,
      &chessMode,
      &treeMode,
      &slideMode,
    };
//------------------------------------------------------------------------------

//-------------Создание объекта (гирлянда) с привязкой к режимам----------------
  Garland garland(modes);
//------------------------------------------------------------------------------

int main()
{
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  RCC::AHB1ENR::GPIOAEN::Enable::Set();


  //Порт С перевести в режим вывода
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();
  GPIOA::MODER::MODER5::Output::Set();

  for(;;)  // вечный цикл
  {
    if(userButton1.IsPressed()) // Если кнопка нажата
    {
      garland.SwithNextMode(); // Меняем режим
    }
    Delay(1000000);
    garland.UpdateCurrentMode(); // обновляем текущий режим светодиодов
  }
}
-------

Результат работы гирлянды с четырьмя режимами и чётным количеством светодиодов представлен в видео.

.4 Режима с чётным количеством светодиодов
Видео прикреплено с названием Четные

С нечётным количеством светодиодов.

.4 Режима с нечётным количеством светодиодов
Видео прикреплено с названием НеЧетные

== Вывод
Я научился грамотно (с возможностью расширения) писать код.
Узнал, что в объектно-ориентированном программировании помогают коротко и аддаптивно писать код такие свойства, как:
абстракция - с помощью неё мы создавали классы и "заворачивали" внутренности в более крупные объекты (пины передавались в светодиоды, светодиоды передавались в режимы, режимы в гирлянду, другими словами, гирлянда управляет только набором режимов, не управляет напрямую пинами),
наследование - которое позволяло перенимать родительские свойства (например все разновидности режимов имеют общего родителя - IMode, в котором описаны два метода, и эти же два метода перенимались дочерними режимами),
инкапсуляция - благодаря которой можно скрывать атрибуты класса, для того чтобы они не были видны извне.
Я разработал программу Гирлянда, которая согласно заданию, светит светодиодами в разных режимах.

